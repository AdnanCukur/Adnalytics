{"version":3,"file":"adnalytics.umd.js","sources":["../src/app/Settings.ts","../src/app/AdnalyticsObserver.ts","../src/app/AdnalyticsStore.ts","../src/app/Init.ts"],"sourcesContent":["export class Settings {\r\n  public static profile: string\r\n  public static onEventAttrName: string\r\n  public static callback: Function\r\n}\r\n","import { Init } from \"../Adnalytics\";\r\nimport { Settings } from \"./Settings\";\r\n\r\n/**\r\n * Observes DOM changes to be able to catch if a new element gets added to the dom that should attach event listeners.\r\n * SPA's and lazy loaded content won't work without this.\r\n * Doesnt work for IE <= 10\r\n */\r\nexport class AdnalyticsObserver {\r\n  public static register() {\r\n    // check if browser supports mutation observer, if not return.\r\n    if (!(\"MutationObserver\" in window)) {\r\n      return;\r\n    }\r\n\r\n    let observer: MutationObserver = new MutationObserver(mutations => {\r\n      mutations.forEach((mutation: MutationRecord): void => {\r\n        AdnalyticsObserver.handleDomMutation(mutation);\r\n      });\r\n    });\r\n\r\n    observer.observe(document.body, {\r\n      childList: true,\r\n      subtree: true,\r\n      attributes: false,\r\n      characterData: false\r\n    });\r\n  }\r\n  private static handleDomMutation(mutation: any): void {\r\n    if (!mutation.addedNodes) {\r\n      return;\r\n    }\r\n\r\n    for (let i: number = 0; i < mutation.addedNodes.length; i++) {\r\n      let node: HTMLElement = mutation.addedNodes[i] as HTMLElement;\r\n      if (node == null || node.id == null || node.className == null) {\r\n        return;\r\n      }\r\n\r\n      AdnalyticsObserver.handleAddedDomElement(node);\r\n    }\r\n  }\r\n\r\n  private static handleAddedDomElement(element: HTMLElement): void {\r\n    // check if added dom element is an adnalytics element and if it is attach listeners to it\r\n    if (AdnalyticsObserver.elementIsAdnalyticsElement(element)) {\r\n      Init.attachListeners(element);\r\n    }\r\n\r\n    // check if added dom element contains adnalytics elements and if it does\r\n    // attach listeners to every one of those elements\r\n    let adnalyticsElementsInside: NodeListOf<\r\n      Element\r\n    > = AdnalyticsObserver.elementContainsAdnalyticsElements(element);\r\n    if (adnalyticsElementsInside.length > 0) {\r\n      for (let i: number = 0; i < adnalyticsElementsInside.length; i++) {\r\n        let node: HTMLElement = adnalyticsElementsInside.item(i) as HTMLElement;\r\n        Init.attachListeners(node);\r\n      }\r\n    }\r\n  }\r\n\r\n  private static elementIsAdnalyticsElement(element: HTMLElement): boolean {\r\n    if(!element.className) return false;\r\n    let classnames: string[] = element.className.split(\" \");\r\n    for (let i: number = 0; i < classnames.length; i++) {\r\n      if (classnames[i].indexOf(Settings.profile) === 0) {\r\n        return true;\r\n      }\r\n    }\r\n    return false;\r\n  }\r\n  private static elementContainsAdnalyticsElements(\r\n    element: HTMLElement\r\n  ): NodeListOf<Element> {\r\n    return element.getElementsByClassName(Settings.profile);\r\n  }\r\n}\r\n","/**\r\n * Makes sure we don't get duplicate event listeners on the same dom element\r\n */\r\nexport class AdnalyticsStore {\r\n  public static store: any = {}\r\n  private static count: number = 0\r\n  public static add(element: any): void {\r\n    element.__data = AdnalyticsStore.count++\r\n    AdnalyticsStore.store[element.__data] = 1\r\n  }\r\n  public static exists(element: any): boolean {\r\n    if (AdnalyticsStore.store[element.__data] != null) {\r\n      return true\r\n    }\r\n    return false\r\n  }\r\n}\r\n","import { AdnalyticsObserver } from \"./AdnalyticsObserver\";\r\nimport { AdnalyticsStore } from \"./AdnalyticsStore\";\r\nimport { Settings } from \"./Settings\";\r\n\r\n/** registers the observer which observers changes made to the dom\r\n *  initiates the initial scan of elements\r\n */\r\nexport class Init {\r\n  constructor(options: AdnalyticsOptions) {\r\n    Init.setSettings(options);\r\n    AdnalyticsObserver.register();\r\n    Init.scan();\r\n  }\r\n  public static setSettings(options: AdnalyticsOptions) {\r\n    Settings.profile = options.profile;\r\n    Settings.onEventAttrName = options.profile + \"-on\";\r\n    Settings.callback = options.callback;\r\n  }\r\n\r\n  /**\r\n   * Scans the dom for the profile class and attaches a listener to the elements\r\n   */\r\n  public static scan(): void {\r\n    let allAdnalyticsElements: HTMLCollectionOf<\r\n      Element\r\n    > = document.getElementsByClassName(Settings.profile);\r\n    for (let i = 0; i < allAdnalyticsElements.length; i++) {\r\n      let node: HTMLElement = allAdnalyticsElements.item(i) as HTMLElement;\r\n      Init.attachListeners(node);\r\n    }\r\n  }\r\n  /**\r\n   * Attaches a listener to the element which then calls the callback method\r\n   * when triggered with the belonging profile attributes as an object\r\n   * ex: <p class='myprofile' myprofile-on='click' myprofile-name='peter' myprofile-id='4'>text..</p>\r\n   *     will trigger the callback function when the element is clicked on with an object {name:\"peter\", id:\"4\"}\r\n   * @param node element with the profile class\r\n   */\r\n  public static attachListeners(node: HTMLElement): void {\r\n    if (AdnalyticsStore.exists(node)) {\r\n      return;\r\n    }\r\n    AdnalyticsStore.add(node);\r\n    let attributes: NamedNodeMap = node.attributes;\r\n    let onEvent: Attr | null = attributes.getNamedItem(Settings.onEventAttrName);\r\n    if(!onEvent) return;\r\n    let analyticsObject: any = {};\r\n    for (let i: number = 0; i < attributes.length; i++) {\r\n      let attributeName: string = attributes[i].name;\r\n      let attributeValue: string = attributes[i].value;\r\n      if (\r\n        attributeName.indexOf(Settings.profile) === 0 &&\r\n        attributeName !== Settings.onEventAttrName\r\n      ) {\r\n        analyticsObject[\r\n          attributeName.replace(Settings.profile + \"-\", \"\")\r\n        ] = attributeValue;\r\n      }\r\n    }\r\n    if (onEvent.value === \"load\") {\r\n      Settings.callback(analyticsObject);\r\n    } else{\r\n      node.addEventListener(onEvent.value, (e: Event) => {\r\n        Settings.callback(analyticsObject);\r\n      });\r\n    }\r\n  }\r\n}\r\nexport class AdnalyticsOptions {\r\n  profile!: string;\r\n  callback!: Function;\r\n}\r\n"],"names":[],"mappings":"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"}